MVC 5 Course from Mosh Hamedani
--------------------------------
What is MVC?
------------
	-> MVC is one of the Architectural Pattern for implementing user interfaces.
	-> it stands for Model(data and business logic), View(UI), Controller(handles user input).
	-> It always have another component which is not in the Acronym - "Router" which selects the right controller/action method to handle the request based on certain rules.
	
What is Architecture?
-----------------------
	-> Software architecture is high level structure of the system or blueprint of the system that outlines how different
components of the system interact and work together to achieve the overall goals of the system.	
	
What is Architectural Pattern?
-------------------------------
	-> General design pattern helps to architecture the system in way to have better scalability, maintainability, flexibility and other desirable qualities to solve the common problem that occur, these guidelines are well tested over many years and developed by the community for solving commonly occuring problems.
		Examples:
					-> Layered Architecture
					-> Client-Server Architecture
					-> Model-View-Controller Architecture
							-> MVC pattern says Router will select the controller/action based on the URI and pass the request to that particular action method, controller facilitates fetching the data (model) and passing the data to UI and return response.
					-> Microservices Architecture
					-> Event-Driven Architecture
					-> Singleton Pattern
					-> Observer Pattern
					
					
Creating .Net Framework Project with MVC:
-----------------------------------------
RouteConfig.cs -> in App_Start folder -> has the rules defined for route.
Global.asax.cs -> class which hooks for various events in the application life cycle.
					-> When the application starts, Application_start method starts execution and it does register some of the things like RegisterRoutes().
					-> it basically tells the run time these are the routes for the application.

Packages.config -> similar to npm to manage dependent packages of our application.					
				-> all the dependent packages/libraries will be updated/managed by using packages.config

Startup.cs -> all the startup logic for the application will be moved to this file from .Net core, dropping Global.asax file.
Web.config: 
------------
		Mostly we will work only in 2 sections in this xml - ConnectionString (define DB connection) and AppSettings (define configuration settings for our application)			
					
We will start adding models (POCO - plain old clr or c# objects) which represents the state and behavior of our application in terms of the problem domain.	

For eg:
--------
public class Movie //in this case it does not have any behavior, but only properties.
{
    public int Id { get; set; }
    public string  Name { get; set; }
}

To make a controller to handle our request and return response, we have to add a controller file in controllers folder,
for eg; MoviesController which is just another class but it becomes powerful when it derived from Controller class, because that provides the ability/methods for the MoviesController class to handle and responde to http request that are made to the ASP.Net MVC web site.

	Example: Json(), View(), OnActionExecuting(),OnActionExecuted(), OnAuthentication(), OnException(), PartialView(), RedirectToAction(),RedirectToRoute()
			Properties like Request (Gets HttpRequestBase object for current Http request), Response (Gets HttpResponseBase object for current HttpResponse), User (Gets user security information for current Http request) etc.,
			
	We can even place the controller class inside models, but recommended and most followed practice is to keep controller classes inside Controller folder.

MoviesController:
------------------
  public class MoviesController : Controller
  {
      // GET: Movies
      public ActionResult Index()
      {
          var movies = new List<Movie>()
          {
              new Movie { Id = 1, Name = "Shrek!" },
              new Movie { Id = 2, Name = "Dark" },
              new Movie { Id = 3, Name = "Just love!" }
          };
          
          return View(movies);
  }
  
 Corresponding View:
------------------------
@model IEnumerable<Vidly.Models.Movie>
@{
    ViewBag.Title = "Index";
    Layout = "~/Views/Shared/_Layout.cshtml";
}

<h2>Movies List</h2>

@foreach (var item in Model)
{
    <h5>@item.Name</h5>
}


To change theme of the default project:
---------------------------------------
	-> Go to Bootswatch.com -> Themes -> Select from multiple option. I select Pulse and downloaded Bootstrap.css file.
	-> Renamed it as Bootstrap-pulse.cs and placed it in content folder where bootstrap files are present.
	-> To make our project to use this Bootstrap-pulse.css file, go to RegsiterBundles in BundleConfig.cs -> where the client side files (js, css) are bundled so that in one http request all the files will be loaded without making multiple http request for each style/js files.
	
	There we can make the css style bundle to point to this new theme file.	Theme would be altered for the app.
	
            bundles.Add(new StyleBundle("~/Content/css").Include(
                      "~/Content/bootstrap-minty.css",
                      "~/Content/site.css"));
 
 
ASP.Net MVC Fundamentals:
--------------------------
	ActionResult:
	-------------
		-> We can see that from action method, that it is returning ActionResult - what is it?
		-> it is an abstract class having abstract method ExecuteResult()
		-> basically it is derived by different result classes, viewResult, JsonResult, ContentResult, RedirectResult(to redirect to URI), RedirectToRouteResult(redirects to a route) etc.,
		
	But what does return View() do - we have not mentioned anywhere ViewResult? Then how does it return ViewResult object.
	Actually there is a helper method defined in Controller class to return specific ActionResult object(since all viewResult, jsonResult, ContentResult etc., are derived from ActionResult).
	
	So, the code:
						"return View(model);" 
		returns a ViewResult object using the model that renders view to the response.

See below eg; This code is from Controller class;
--------------------------------------------------
    protected internal virtual ViewResult View(string viewName, string masterName, object model)
    {
        if (model != null)
        {
            base.ViewData.Model = model;
        }

        return new ViewResult
        {
            ViewName = viewName,
            MasterName = masterName,
            ViewData = base.ViewData,
            TempData = base.TempData,
            ViewEngineCollection = ViewEngineCollection
        };
    }
	
So like this, for different types of ActionResult, there is a helper method present in Controller class like below;
-----------------------------------------
PartialViewResult - PartialView()
ContentResult     - Content()
RedirectResult    - Redirect()
RedirectToRoute   - RedirectToAction()
JsonResult        - Json()
FileResult        - File()
HttpNotFoundResult- HttpNotFound()
EmptyResult       - no helper method (as per the course 2016)
----------------------------------------

If suppose we want to redirect request to different route/action/controller, we can do it like below;

return RedirectToAction("Index", "Home", new { page = 1, sortBy = "name" });

in this "new { page = 1, sortBy = "name" }" this portion is know as anonymous object.

in the URI - it looks below; https://localhost:44318/?page=1&sortBy=name after redirection.

Action Parameters:
-------------------
	--> ActionResult is the output from Action, Action Parameters is the input to the Action methods.
	--> MVC Framework does the parameter binding automatically from URI to action parameters.
For eg;
------
		https://localhost:44318/movies/edit/23?movieId=300 
		This movieId will bind to the below action method;
		 
			public ActionResult Edit(int? movieId)
			{
				return Content(String.Format("id = {0}", movieId));
			}
			
		but the same would not work when the request is simply; https://localhost:44318/movies/edit/300
			as per the default route this is termed as {id}

	See RouteConfig:
	-----------------
		routes.MapRoute(
							name: "Default",
							url: "{controller}/{action}/{id}",
							defaults: new { controller = "Home", action = "Index", id = UrlParameter.Optional }
						);
						
		But if i make it changed to "{controller}/{action}/{movieId}"	- then it will work;
		
		But if suppose, we want to have our url like below;
			
		https://localhost:44318/movies/random/pageIndex=2&sortBy=Name
		
		When I have below action method, then above URI works.
		
				    public ActionResult Random(int? pageIndex, string sortBy)
					{
						return Content(String.Format("pageIndex = {0}, sortBy={1}", pageIndex.Value, sortBy));
					}
		
But instead of query string if we want to call like; 		
		
		https://localhost:44318/movies/random/pageIndex/2/sortBy/Name
		or 
		https://localhost:44318/movies/random/2/Name
		
	These won't work as per our current route config, we have to have a custom route defined for handling these kind of URLs.	
	Because the way the current routing works called as Conventional based routing.
	
	But when we have scenarios like to pass multiple parameters to fetch the data.
	Suppose in our app, we want to fetch all the movies by release year and month like below;
						
						"/movies/released/2015/04"
						
	Custom route defined: it has multiple overloads, generally used one, name, url, defaults
	---------------------
		routes.MapRoute(
						name: "ByReleaseDate",
						url: "movies/released/{year}/{month}",
						defaults: new
						{
							controller = "Movies", action = "ByReleaseDate", year = 2020, month = 01
						},
						
						new {year = @"\d{4}", month=@"\d{1,2}"}
						); 
						
		"new {year = @"\d{4}", month=@"\d{1,2}"}" --> constraints can be added in the route, here year should 	be 4 digits, month to have 1 or 2 digit.				
		
		The result URL: https://localhost:44318/movies/released/2022/14				

Attribute Routing:
------------------
		In the above approach, we have just added just one custom route in RouteConfig, but overtime, there would be needing a lot of custom routes to be defined and this file would become messy and error prone as we are entering the hard coded string for action name, if at all we change the action name in the controller, this will cause issues. It becomes unmaintainable.
		
		Instead of this, we can give custom route defined just above the action method itself, so we won't have such above issues.

		To use Attribute Routing, we need to enable it in RouteConfig.cs.
					
					routes.MapMvcAttributeRoutes();
					
		Above action method, we can use Route Attribute to provide the required url to hit the respective action.
		Eg:
		--
			       [Route("movies/released/{year:min(1960):max(2023)}/{month:max(12)}")]
					public ActionResult ByReleaseDate(int year, int month)
					{
						return Content($"year: {year}, month:{month}");
					}
					
			We can also provide constraints in the route parameter by {year:min(1960)}/{month:max(12)}	

				https://localhost:44318/movies/released/2024/12 - this does not work, says 404 - due to constraints specified as it works only from 1960 - 2023.

Passing Data to Views:
----------------------
	Different ways of passing data to views, most easy and better one is pass it as model.
	One of the early days of MVC, ViewDataDictionary was the one used for passing data from controller to views.
	But since this is dynamic type, we have to do explicit casting in View to use it.
	
	ViewData: this comes from ControllerBase class.
	---------
	
			@foreach (var item in (List<Movie>)ViewData["movies"])//explicit casting and same hard coded string.
			{
				<h5>@item.Name</h5>
			}
	From Controller: 
	-----------------
			public ActionResult Index()
			{
				var movies = new List<Movie>()
				{
					new Movie { Id = 1, Name = "Shrek!" },
					new Movie { Id = 2, Name = "Dark" },
					new Movie { Id = 3, Name = "Just love!" }
				};
			
				ViewData["movies"] = movies;
				
				return View();
			}
	ViewBag: this also come from ControllerBase class - it is dynamic view data dictionary.
	--------
		@foreach (var item in ViewBag.movies)
		{
			<h5>@item.Name</h5>
		}
	From Controller:
	----------------
		 ViewBag.movies = movies; //instead of hard coded string, it is dynamic property, but here also if there are typo, no compile time check.
		 
Passing View Models to View:
----------------------------
			View Models are models specific to Views.
			This generally goes to seperate folder (ViewModels) than Models. As models folder is specific to domain classes which is independent of UI.	
					
RazorView Syntax:
------------------	
		This helps writing C# syntax and html tags together.
		Basically, the ViewEngine in the MVC called Razor View Engine knows how to parse the syntax and understand.

								Example: (MoviesWithRentedCustomers.cshtml)
								--------------------------------------------
								@model Vidly.ViewModels.MovieCustomersViewModel
								
								@{
									ViewBag.Title = "title";
									Layout = "~/Views/Shared/_Layout.cshtml";
								}
								
								<h2>@Model.Movie.Name</h2>
								
								<ul>
									@foreach (var item in Model.Customers)
									{
										<li>@item.Name</li>
									}
								</ul>
								
Partial Views:
---------------
		Reusable views. Does not have a Layout.
		General convention is to prefix partial view with "_" like "_Layout" , "_NavBar"

Sample
-------
	 @Html.Partial("_NavBar");
	 <div class="container body-content">
		 @RenderBody()
		 <hr />
		 <footer>
			 <p>&copy; @DateTime.Now.Year - My ASP.NET Application</p>
		 </footer>
	 </div>		
	 
But it looks like there is no distinction between partial view or regular views, it is just the convention and assumption made by the framework to locate the file and render.

		@Html - HtmlHelper Property - it has some useful methods to create and render html elements in View.
		
Exercise to show Customer, Movies link in NavBar and on click show respective customer as link ->which redirects to details. But movie link is not a link, if we want we can make it.		
		
						Mosh - GitHub Link - https://github.com/mosh-hamedani/	

ENTITY FRAMEWORK:
------------------
	What is entity framework?
		It is basically a Object/Relational Mapper(ORM) tool which means it maps data in a relational database into objects of our application.
		Old days, this mapping of data to objects needed to be done manually by;
			-> Opening a connection
			-> Executing a command
			-> Reading data
			-> Form an object.
			-> finally remembering to close the connection.
			
	With ORM, we don't have to do this steps anymore, it is automatically done for us by the framework, we work at a higher level of abstraction.
		EF provides a called "DbContext" which is a gateway to our database.
		
			DbContext ----------> DbSet/s 
			(database)			  (table)
			
		We use LINQ to query the DbSet, EF will translate it to SQL queries at run time which opens the Db connection, reads the data, maps it to objects and adds them to DbSet in DbContext.
		
	So when Add/Delete/Update to our DbSet, EF keeps track of these changes, once we ask for it to persist the changes, it will automatically generate the SQL statements and executes them on Database.

	Two workflows to use EF;
			-> Database First
					- Traditional way to design database tables first and then have EF generate the corresponding domain classes.
					----------------------------------
					|Domain Classes <= EF <= Database|
					----------------------------------
			-> Code First
					- This is opposite to above approach, we will create domain classes first, then have Entity Framework to generate DB tables. 
					----------------------------------
					|Domain Classes => EF => Database|
					----------------------------------
					
		So as part of this course, we are going to take Code First approach and here are the reasons why?
				-> Increases Productivity as we don't have to waste our time with table designers.\
				-> its very much faster to write code.
				-> when we have code first, we get full versioning of the database and can be migrated to any version any point in time. Since we use migrations in code first approach it is possible.
				-> Much easier to build integration test db.
		
		Few misconceptions about Code First approach: (these are true myths)
		---------------------------------------------	
			-> This is only useful with new projects or greenfield projects.
			-> If you have a application with existing database, code first do not work.
			-> it does not give you full control over db.

CODE FIRST MIGRATIONS:
----------------------
	What are migrations?
	--------------------
		-> In EF, migrations are the way to manage changes to the database schema over time. They provide a way to update the database to reflect the changes from data model (like adding/modifying columns or relationships).
		-> It is simply a set of instructions, which tells how the database schema should be updated.
		-> EF also keeps track of which migrations applied to the database, this version tracking helps ensure that the database schema is in sync with the application's data model.	
		
	Steps and flow:
	---------------	
		-> In Code first workflow, we start with code, everytime we modify our domain model by adding/modifying class, we create a migration and run it on the database.
		
		-> First install Entity Framework from Tools -> Nuget Package Manager -> Manage Nuget Packages for Solution -> 	  Search for Entity Framework -> install
			
		-> Before adding migration, we need to enable migrations by using "enable-migrations".
		-> once enabled, Add-Migrations InitialModel(describing message about the change)
		-> Adds a migration file in the "Migrations" folder - it clearly tells about the change - if it is createTable, or any other change, this file would be derived from DbMigration class which has methods to createTable, AddColumn, DropColumn etc.,
		
		-> To update database -use "update-database".\
		-> pushes changes to the database/updates the database.
		-> here in this case, click on "show all files" -> App_Data folder -> check the .mdf file created. where the tables are created.
		
		-> We can find our customers, movies table over there, also we can find another table _MigrationHistory which maintains the history of migrations applied on this database.
			
		-> With this Entity framework knows what version of database our application currently at.
	
Changing the Model:
--------------------
	-> In the vidly app, right now the domain classes are very simple. 
	-> if suppose we want to add few more properties to Customer, like (their MemberShipType, IsSubscribedToNewsletter).
	-> MemberShipType can have information like SignUpFee, Duration, DiscountRate.
	-> Each customer can have one and only MemberShipType.
		
		In this SignUpFee cannot be more than 32000$, for that we can have short type.
		Duration - can be between 1-12 months - so byte type (-127 to +128)
		DiscountRate - can be between (10% - 100%) so byte type.
		Any entity in EF should have primary key, by convention it should be named Id or EntityName + Id.
		Here in MemberShipType's "Id" can be of byte type as the MemberShipTypes would be 4 or 5 itself.	
		
		MemberShipType is known as Navigation property, because it allows us to navigate from one type to another, here from Customer type to its MemberShipType. 
			-> its useful when we want to load an object and its related objects together from the database.
			-> Here, we can load the customer and its MembershipType together.
		If suppose we don't to load all the related objects together, for optimization purpose, we can have another property by naming convention - MemberShipTypeId - EF recognizes it as foreign key.	
		
						public byte MembershipTypeId { get; set; }
		
For making this changes, we will aim for small migrations and keep adding further, instead of making all these changes at once and going big migration which is error prone.

Seeding the Database:
---------------------
		Seeding the data to the MemberShipType table as it do not have any records still.
		Pay-as-you-go - Free, Monthly - 30$, Quarterly - 90$, Annually - 300$		

						"Add-Migration PopulateMembershipType"
		
		In the Up method;
			public override void Up()
			{
				Sql("INSERT INTO MembershipTypes(Id, SignUpFee, DurationInMonths, DiscountRate) VALUES(1,0,0,0)");
				Sql("INSERT INTO MembershipTypes(Id, SignUpFee, DurationInMonths, DiscountRate) VALUES(2,30,1,10)");
				Sql("INSERT INTO MembershipTypes(Id, SignUpFee, DurationInMonths, DiscountRate) VALUES(3,90,3,15)");
				Sql("INSERT INTO MembershipTypes(Id, SignUpFee, DurationInMonths, DiscountRate) VALUES(4,300,12,20)");
			}
			
						"update-database"
						
		If you notice in the Migration_History, we have all the migrations from start executed, in this way, we can have the Migration SQL script created by using a command in Package manager console to include all these migrations in single file and get it executed in a test/production environment as we have the scripts ready in hand with this versioning of migrations.
		
		If we do it manually, then we need to have it maintained somewhere or consolidated from multiple developers tpo get it executed in test or production environment. And you know its very tough.
			
			
Overriding Conventions:
-----------------------
		Since, we have given Name property in Customer is string type - which is nullable, EF also generates it as a nullable field and nvarchar(max) length.
		We can use DataAnnotations to override these conventions.
		
		After using DataAnnotations (Required, StringLength(255) on Name property) after add-migration, update-database
		the database schema is updated with column name now have nullable: false, maxLength: 255
		
Querying objects:
-----------------
		Currently, the customer details are hardcoded in Customer controller and sent to view.
		If we need to query the customers from Database, we will instantiate the VidlyDbContext (as this is the gateway to access our db tables).
                                   var customers = _context.Customers;//deferred execution.
								   
				One thing to note here is when this line is executed, "_context.Customers" - it will not immediately fire queries to fetch data from db, instead it only fetch data when we iterate over.	
					But if suppose, we have ; var customers = _context.Customers.ToList(); it fires the query immediately.
					
Eager Loading:
--------------
		If suppose in the above case, we have another column showing DiscountRate for the customer means, we have to have another column added in view, to get the data for that column, 
		
								"@item.MemberShipType.DiscountRate"	
								
				But when we do this, what happens is object reference exception. Why because when loading the Customer object, it does not load MemberShipType object.				
		To make it load, we need to do something called - EagerLoading.
		When loading customers, we have to use Include method from System.Data.Entity namespace.
						
						 var customers = _context.Customers.Include(x=> x.MembershipType).ToList();
						 
To create a shortcut for package manager console:
--------------------------------------------------
							Tools -> Options -> Environment -> Keyboard -> type packagemanagerconsole -> Press respective keys and Assign -> I assigned "ALT + Y" - it is working fine.
							
Exercise 1:
-----------
	Instead of showing DiscountRate in Customers-> Index, show MemberShipType name (note we do not have name property in MemberShipType domain class)
			-> Add Name property to MemberShipType class.
			-> Add-Migration Added-Name-MembershipType
			-> update-database
			-> Add- Migration Update-MemberShipType-Name
			-> Use SQL method in Up() method to provide update statement to update name for all membershiptypes.
							
							
Exercise 2: 
------------
	Add Birthdate to Customer

Exercise 3:
------------
	Display List of movies and their details (Release Date, Genre, Date Added).	

Lets Add Forms:
----------------
	-> For Adding/Editing Customers/Movies.
	-> For that first we need an action in Controller to bring the Create Form where user can enter their details like (Name, Birthdate, Subscribed to newsletter) fields for customers.
    -> For movies it would be (Name, Genre, ReleaseDate, AddedDate, NumberInStock)	
	
	For Adding Customer, add an action method (create) in Customers Controller which returns a View(form).
	View contains form controls for user to provide the details.
	So in plain html, we use form tag -> input fields, labels.
	Here in this, we can use Html helper methods to add html controls.
	
	Some of the html controls are; and in bootstrap it follows the certain classes to have it styled in modern manner.

/*************************************************************************************************/	
@using (Html.BeginForm("Create", "Customers"))//by using tag, it automatically closes </form> tag at the end.
{
    <div class="form-group">
        @Html.LabelFor(m => m.Name)
        @Html.TextBoxFor(m => m.Name, new { @class = "form-control" })
    </div>
    <div class="form-group">
        @Html.LabelFor(m => m.BirthDate)
        @Html.TextBoxFor(m => m.BirthDate, new { @class = "form-control" })
    </div>
    <div class="form-check">
        <label class="form-check-label">
            @Html.CheckBoxFor(m => m.IsSubscribedToNewsletter, new {@class="form-check-input"})
            @Html.LabelFor(m => m.IsSubscribedToNewsletter)
        </label>
    </div>
}

/*************************************************************************************************/	
	
For movies it would be (Name, Genre, ReleaseDate, AddedDate, NumberInStock)	
	
When we add Display - DataAnnotations to provide display name for the field, then we have to be aware of the fact that if we want to rename the label to show different way, then we have to rename it in model class and recompile the code and deploy for just label renaming.
		In that case, we can go for plain label tag to provide the display text manually. But "for" attribute need to be manually entered to get that effect of on click of label the form control gets focus.

			" <label for="BirthDate">Date of Birth</label> 
			 @Html.TextBoxFor(m => m.BirthDate, new { @class = "form-control" }) "
			
		Here is the risk, if we don't give the BirthDate name properly, the effect of focus do not work properly.

		
		
Drop-down Lists:
-----------------
	-> If we have to add a drop down for the customer form to select the respective MemberShipType (Pay-as-you-go, Quarterly, Monthly, Annually) a dropdown list.
	-> Currently, the customer create form takes the customer model, which does not have the entity for MemberShipTypes, So basically we need a Customer entity as well as MemberShipTypes entity as well to Create form for Customer.
	-> So lets add a ViewModel property which takes Customer and MemberShipType together.

Example:
---------
 <div class="form-group">
     @Html.LabelFor(m=> m.Customer.MembershipTypeId,
 new {@class="pb-2"}) 
     @Html.DropDownListFor(m=> m.Customer.MembershipTypeId, new SelectList(Model.MembershipTypes, "Id", "Name"), 
         "Select Membership Type", 
         new {@class = "form-select"})
 </div>	

						"class="form-select" makes the dropdown display properly."
						
Model Binding:
---------------
	MVC framework automatically binds the action parameters with the request data.
	
Saving Data:
------------
	Need to have a new action created to handle to post request - [HttpPost] to make sure this action method can be called via HttpPost not through Get request.
	
	-> As a best practice, if the action method does modify the data, it should never be accessible by HttpGet.
	-> Once the payload is received, which is then mapped to the customer parameter. 
	-> To add it to the database, we need to add it in the Customers DbSet in DbContext class.
	-> Once it is added, then to persist/commit the changes to DB, use SaveChanges() method, which then collects all the changes done on the entity (modification, addition, deletion) and fires up the queries to make the changes to Database. 
	-> This all things done under a transaction, so that if any fails, all changes gets rolled back.
	
See example below;
-------------------	

 [HttpPost]
 public ActionResult Create(Customer customer)
 {
    _context.Customers.Add(customer);
    _context.SaveChanges();
    return RedirectToAction("Index");
 }	
 
 Editing Customer:
 -----------------
	-> Since we use the same view model (NewCustomerViewModel) as this form also will show same controls, customer data, Membership dropdown. We can rename the View model to little more generic as "CustomerFormViewModel".
	-> As we already have a view to show these controls - "Create" for edit also we can use the same View with same controls just filled with existing data, so we can rename view name also to "CustomerForm" to be more generic for Create/Edit scenario.
	-> And also the same for post method, as right now it is called as Create (HttpPost), we can have the method named as "Save" to be more generic for Create/Edit, we will just check if the customer payload has "id" value == 0 - then it goes add logic, else go to edit logic. Add the id property as hidden field in the "CustomerForm.cshtml"
	
See below example:
-------------------
        [HttpPost]
        public ActionResult Save(Customer customer)
        {
            if(customer.Id == 0)
                _context.Customers.Add(customer);
            else
            {
                var customerInDb = _context.Customers.Single(c => c.Id == customer.Id);
                //TryUpdateModel or autoMapper - but these updates entire model, sometimes we may need only specific properties to be updated
                customerInDb.Name = customer.Name;
                customerInDb.MembershipTypeId = customer.MembershipTypeId;
                customerInDb.BirthDate = customer.BirthDate;
                customerInDb.IsSubscribedToNewsletter = customer.IsSubscribedToNewsletter;
            }
            _context.SaveChanges();
            return RedirectToAction("Index");
        }	
		
Exercise:
---------		
	Similar have a Add new movie link in Movies list view, and on click of that -> open Add Movie form -> with controls, Name, Release Date, Genre (ddl), Number in Stock fields and save button.
	
		-> add the link added in Movies list view
		-> add an action for New movie in movies controller
		-> create the new movie form view with fields and button to save.
		-> add a new action to save the new movie created.
		-> Add Genre DbSet in DbContext.
		
	After all done, when saving it is giving EntityValidationError, though we enter all the fields in UI, I can see, we have DateAdded property is also required, but as per UI, we do not have that field, that should be the reason for this validation message, lets check in the next section video if he explains that.
		-> We may need to add that property in UI or use Today property set everytime, we try to add a new movie.
		
	Edit Movie:
	------------
		Same MovieForm would be called from Edit Click -> Same MovieFormViewModel is passed back to Edit Action to show the same form with filled details.

	Edit Action:
	------------
	   public ActionResult Edit(int? Id)
       {
           var movie = _context.Movies.Include(x => x.Genre).FirstOrDefault(x => x.Id == Id);
           var viewModel = new MovieFormViewModel
           {
               Movie = movie,
               Genres = _context.Genres.ToList()
           };
           return View("MovieForm", viewModel);
       }
	   
	   In Movie Form:
	   --------------
					@if (Model.Movie != null)
					{
						<h2>
							Edit Movie
						</h2>
					}
					else
					{
						<h2>
							New Movie
						</h2>
					}
					
	Still not able to save, due to some validation errors.		

Entity Validation Errors Resolved:
-----------------------------------
	It was due to when Genre was required field, but from the form we get only GenreId, for that we have to remove the Required attribute for Genre property from Movie class and we will have a GenreId property added with the "same type" as in Genre class, then EF does not complain about the validation and it automatically resolves the value for GenreId to Genre property (from Id to actual object).	
	
	Save Action Method:
	--------------------
		public ActionResult Save(Movie movie)
        {
            if (movie.Id == 0)
            {
                movie.DateAdded = DateTime.Now;
                //movie.Genre = _context.Genres.FirstOrDefault(x => x.Id == movie.GenreId); this is not needed.
                _context.Movies.Add(movie);
            }
            else
            {
                //edit logic
                var movieInDb = _context.Movies.Include(m=> m.Genre).Single(m=> m.Id == movie.Id);
                if (movieInDb != null)
                {
                     movieInDb.Name = movie.Name;
                     movieInDb.GenreId = movie.GenreId;//_context.Genres.FirstOrDefault(x => x.Id == movie.GenreId);
                     movieInDb.ReleaseDate = movie.ReleaseDate;
                     movieInDb.NumberInStock = movie.NumberInStock;
                     movieInDb.DateAdded = DateTime.Now;
                }
            }
            
            _context.SaveChanges();
            return RedirectToAction("Index");
        }
		
	Movie domain class:
	-------------------
				    public class Movie
					{
						public int Id { get; set; }
						public string  Name { get; set; }
						
						[Required]
						[Display(Name = "Release Date")]
						public DateTime ReleaseDate { get; set; }
						
						[Required]//Actually this Required also can be removed as it is not a field in the form.
						[Display(Name = "Date Added")]
						public DateTime DateAdded { get; set; }
						
						[Required]
						[Display(Name = "Number in Stock")]
						public short NumberInStock { get; set; }  
						
						public Genre Genre { get; set; }
						[Required]
						public int GenreId { get; set; }
					}
		
Implementing Validations on Form:
----------------------------------
	Before Saving the data to database, we need to validate if the data / object is proper or without any errors as per our DataAnnotations set on the domain model entity. 
	We can check that with the help of "ModelState" objects "IsValid" property, which checks any of the model property has any Errors or not, if it is then it returns "false", if it is valid then returns "true".
	To show this in UI, we need to have a place holder added in the form - using @Html.ValidationMessageFor(m=> m.Customer.Name)
	
Customers Controller:
----------------------	
Save Method:
=============
        [HttpPost]
        public ActionResult Save(Customer customer)
        {
            if (!ModelState.IsValid) //Checks if the model property has any error
            {
                var viewModel = new CustomerFormViewModel
                {
                    Customer = customer,
                    MembershipTypes = _context.MembershipTypes.ToList()
                };

                return View("CustomerForm", viewModel);
            }

            if(customer.Id == 0)
                _context.Customers.Add(customer);
            else
            {
                var customerInDb = _context.Customers.Single(c => c.Id == customer.Id);
                //TryUpdateModel or autoMapper - but these updates entire model, sometimes we may need only specific properties to be updated
                customerInDb.Name = customer.Name;
                customerInDb.MembershipTypeId = customer.MembershipTypeId;
                customerInDb.BirthDate = customer.BirthDate;
                customerInDb.IsSubscribedToNewsletter = customer.IsSubscribedToNewsletter;
            }
            _context.SaveChanges();
            return RedirectToAction("Index");
        }
		
Some DataAnnotations:
----------------------
[Range(1,10)]
[Compare("Other Property")]
[Phone][Email][Url]

Custom Validation / Data Annotation
------------------------------------
If suppose I need a validation to be set for any customer to be on a membershiptype other than Pay-as-you-go, they should be atleast 18 years old.

How can I do that?
	-> Well, we can create a Custom DataAnnotation like 'Minimum18YearsAge' and apply it on birthdate property.
	-> And how we will apply the validation logic to check if the membershiptype selected is Pay-as-you-go or other? 
	-> For this we can check [Required] attribute is designed, "RequiredAttribute" is a class derived from "ValidationAttribute" class 	which is derived from "Attribute" class which is a abstract class.
	
Here is the class - "Minimum18YearsAge"

namespace Vidly.Models
{
    public class Minimum18YearsAge : ValidationAttribute
    {
        protected override ValidationResult IsValid(object value, ValidationContext validationContext)
        {
            //check if the membership selected is pay-as-you-go, if not then check age limit, if yes, just return success
            //so to check the other property here(MemberShipType), this valiationContext object helps.
            var customer = (Customer)validationContext.ObjectInstance;
            if (customer.MembershipTypeId == 0 || customer.MembershipTypeId == 1)
                return ValidationResult.Success;

            if (customer.BirthDate == null)
                return new ValidationResult("Birth date is required");
            var age = GetAgeFromBirthDate(customer.BirthDate);

            if(age >= 18) return ValidationResult.Success;

            return new ValidationResult("Age should be at least 18 years to be on a member");
        }

        private static int GetAgeFromBirthDate(DateTime ?customerBirthDate)
        {
           var age = DateTime.Today.Year - customerBirthDate.Value.Year;
           if (DateTime.Today.Month < customerBirthDate.Value.Month) return age;
           if (DateTime.Today.Day < customerBirthDate.Value.Day) return age;
           age++;

           return age;
        }
    }
}	

For resolving the issue with "The id field is required" validation in Save method, I splitted it to two actions - Create(POST) and Update(POST) - do note it is not [HttpPUT] as it did not work, as from client side, I can only set FormMethod.POST or FormMethod.GET.

In POST, we can exclude Id property using [Bind(Exclude = "Id")] attribute.

With this change, I tested Add and Edit scenarios, it is working as expected.

	"Probably we need to check how/when do we use HttpPUT or HttpDelete action verbs in MVC actions?"
	
Controller:
------------
		[HttpPost]
		public ActionResult Create([Bind(Exclude = "Id")] Customer customer)
		{
			if (!ModelState.IsValid)
			{
				var viewModel = new CustomerFormViewModel
				{
					Customer = customer,
					MembershipTypes = _context.MembershipTypes.ToList()
				};
		
				return View(viewModel);
			}
			_context.Customers.Add(customer);
			_context.SaveChanges();
			return RedirectToAction("Index");
		}

        [HttpPost]//Put does not seem to be supported from view, as formMethod I can set only to FormMethod.POST or FormMethod.GET
        public ActionResult Update(Customer customer)
        {
            if (!ModelState.IsValid)
            {
                var viewModel = new CustomerFormViewModel
                {
                    Customer = customer,
                    MembershipTypes = _context.MembershipTypes.ToList()
                };

                return View("Edit", viewModel);
            }
            else
            {
                var customerInDb = _context.Customers.Single(c => c.Id == customer.Id);
                //TryUpdateModel or autoMapper - but these updates entire model, sometimes we may need only specific properties to be updated
                customerInDb.Name = customer.Name;
                customerInDb.MembershipTypeId = customer.MembershipTypeId;
                customerInDb.BirthDate = customer.BirthDate;
                customerInDb.IsSubscribedToNewsletter = customer.IsSubscribedToNewsletter;
            }
            _context.SaveChanges();
            return RedirectToAction("Index");
        }	
		
Exercise:
----------
			Try adding a Custom Validation Attribute for ReleaseDate - Cannot be future date.
			Atleast 2months old movie only we can add and rent out. (DateShouldBeAtleast2MonthsOld)
			
Solution:
----------
using System;
using System.ComponentModel.DataAnnotations;


namespace Vidly.Models
{
  public class DateShouldBeAtleast2MonthsOld : ValidationAttribute
  {
    protected override ValidationResult IsValid(object value, ValidationContext validationContext)
    {
      if (value == null) return new ValidationResult("Release Date field is required");
      var diff = DateTime.Today - (DateTime)value;
      return diff.Days > 60
        ? ValidationResult.Success
        : new ValidationResult("Movie release date should be at least before 2 months");
    }
  }
}

Movie.cs
--------
        [DateShouldBeAtleast2MonthsOld]
        [Display(Name = "Release Date")]
        public DateTime ReleaseDate { get; set; }
		
Refactoring Magic Numbers:
--------------------------
		The hard coded numbers used in AgeShouldBe18Years validation to be on a Membership. (0 or 1) return success, else validate if the customer is above 18 years and return true or false.
		Just add two fields as Unknown, PayAsYouGo as static members in MembershipType class -> use it in the Custom Validation. 

Minimum18YearsAge:
-------------------		
public class Minimum18YearsAge : ValidationAttribute
 {
   protected override ValidationResult IsValid(object value, ValidationContext validationContext)
   {
     -------------------------
     if (customer.MembershipTypeId == MembershipType.Unknown ||
         customer.MembershipTypeId == MembershipType.PayAsYouGo) return ValidationResult.Success;

     -------------
	 -------------
	 -------------

     return new ValidationResult("Age should be at least 18 years to be on a member");
   }
}

MembershipType class:
----------------------
 public class MembershipType
 {
   public byte Id { get; set; }
   ----------------
   ----------------
   ----------------
   public static readonly byte Unknown = 0;
   public static readonly byte PayAsYouGo = 1;
 }
 
 The same when trying via enum, it needs an extra casting to be done while comparison. 

   protected override ValidationResult IsValid(object value, ValidationContext validationContext)
   {
     -----------------
	 -----------------
 
     if (customer.MembershipTypeId == (byte)MembershipType.Type.Unknown ||
         customer.MembershipTypeId == (byte)MembershipType.Type.PayAsYouGo) return ValidationResult.Success;

    -----------------
	-----------------

     return new ValidationResult("Age should be at least 18 years to be on a member");
   }
   
 MembershipType
 --------------
 public class MembershipType
 {
   public byte Id { get; set; }
	------------
	------------
	------------
    
   public enum Type
   {
     Unknown = 0,
     PayAsYouGo = 1,
   }
 }
 
 But due to this extra casting, Mosh was saying he prefers the static field approach.
 
Validation Summary:
-------------------
	If we want a summary of all the validation errors to be displayed at the top / bottom (mostly at top) we can use ValidationSummary Html helper method.
			@Html.ValidationSummary()
			@Html.ValidationSummary(false, "Please fix the following errors")
				-> false will show the property level validations in the top.
				-> true will hide the individual property level validations in the summary, but if we have given @Html.ValidationFor method below each property, then we can see the validation messages below each control.
				
		One main thing is we have already noticed, Id field was coming as required and we tried splitting of Save to Create (exclude Id field here) and Update method, that Id field is required message we can see	in the ValidationSummary as well.

			Actually that is due to when we generate the New Customer Form, the id field in the customer object is being set to empty string.(notice the value field)
			
			"<input data-val="true" data-val-number="The field Id must be a number." data-val-required="The Id field is required." id="Customer_Id" name="Customer.Id" type="hidden" value="" />"
			
	To resolve it, when we create the new customer form, in the view Model, we were only passing MembershipTypes

								 public ActionResult Create()
								 {
									var membershipTypes = _context.MembershipTypes.ToList();
									var newCustomerViewModel = new CustomerFormViewModel()
									{
										MembershipTypes = membershipTypes
									};
									return View(newCustomerViewModel);
								 },
									
			We can initialize a new customer object and pass it in viewModel, to have the id field gets initialized to default 
			value = 0.	

								  public ActionResult Create()
								  {
									  var membershipTypes = _context.MembershipTypes.ToList();
									  var newCustomerViewModel = new CustomerFormViewModel()
									  {
										  Customer = new Customer(),
										  MembershipTypes = membershipTypes
									  };
									  return View(newCustomerViewModel);
								  }
		After this;
		
			<input data-val="true" data-val-number="The field Id must be a number." data-val-required="The Id field is required." id="Customer_Id" name="Customer.Id" type="hidden" value="0" />
			
Ok right now the Id field required is resolved, I don't see it anymore in the summary, so now again we will make our applicaiton to have same Save method for Create and Update scenario and to use same "CustomerForm.cshtml" instead of seperate ones to confirm we are not having issue anymore.

		-> Rename "Create.cshtml" -> "CustomerForm.cshtml"
		-> Make the create and edit action calls the same "CustomerForm.cshtml"		
		-> From CustomerForm.cshtml -> submit -> Save method instead of Create/Update actions.

		Yes, it is now working fine without any issues. Removed extra Update action, edit.cshtml file to keep the code base simple and clean.	

Client Side Validation
-----------------------
	So far the validations that we have seen happens in the server side, which is absolutely crucial for building secure application.
	It is nice to do validation on the client side as well.
	Benefits of this:
	------------------
		-> Immediate feedback to the user, user do not have to wait for the round trip to the server.
		-> No waste of server side resource just because user makes a mistake filling out form.
		
		So its better to do a basic validation in the client side so that the data is in right format before sending it to the server side to do the extra validation on the server side mainly for security purpose to prevent any malicious user sending invalid data by passing client side validation.

By default, client side validation is not enabled in asp.net application, but why is it so?
--------------------------------------------------------------------------------------------		
		Basically it is due to ASP.NET applications have server side validations enabled by default, and can enable client side validations only if its needed.	
		
		As client side validations are not secure enough, it is not enabled by default.
	
How to enable Client side validation?
--------------------------------------
			@section scripts
			{
				@Scripts.Render("~/bundles/jqueryval");
			}
		
		This takes the help of data annotations which basically have some data-val attributes added to the html elements to make use of jquery validation mechanism.

		To be noted, this validation works only on the basic data annotations, if we have any custom validation this client side validation won't be applicable, if we need, then we have to write some jquery code but most of the cases for custom validation we will be using server side validation itself as that could be having some custom business logic to be validated.

Anti-Forgery Tokens
--------------------
		What I understood is? This token helps in preventing the hacker to have the form submitted from other page, instead of from our application page (customer form, movie form), if it is allowed, then the hacker can create some users who are not actually the real customers and use the rental application illegally.
		
	But what does this token prevent?
	-----------------------------------
		it is C-S-R-F => Cross site request forgery (like a request is forged from third party site) as hacker can trick user to click on a image to take to different site, but the user is still having active session to our application and on load the hacker can have embedded Javascript code to fire up the api to create a customer.
		
	How can it be prevented?
	-------------------------
		We can use a html helper method. @Html.AntiForgeryToken() in the form.
		And also we need to decorate the Action method (Save) with [ValidateAntiForegeryToken]
	
	What does these do? how does this prevention works?	
	----------------------------------------------------
		Basically, it generates and saves the token in the hidden field inside the form using @Html.AntiForgeryToken())() method and the token is saved on the cookie in user machine as well. 
		
		During save, the cookie token and hidden field token gets compared and validated to ensure the request has come from the appropriate form and user computer, not from any third party site.
		
		Basically from third party site, the hacker will not have access to hidden field, due to that when there is a mismatch in the token, the site /request will not get succeeded.	
								
		
	When the values are altered, we get following message, actually the token value in hidden field and cookie do not resemble to be same, but MVC framework does all these generation and validation of token logic to prevent CSRF attacks.

			"The anti-forgery token could not be decrypted. If this application is hosted by a Web Farm or cluster, ensure that all machines are running the same version of ASP.NET Web Pages and that the <machineKey> configuration specifies explicit encryption and validation keys. AutoGenerate cannot be used in a cluster."
	
	Snippet:
	---------
		@using (Html.BeginForm("Save", "Customers"))
		{
			------------------------------
			------------------------------
			@Html.HiddenFor(m => m.Customer.Id);
			<button class="btn btn-primary mt-2 rounded-2" type="submit">Save</button>
		
			@Html.AntiForgeryToken() //generates a token and save it in cookie as well as hidden field.
		}
		
	In controller:
	---------------
		 [HttpPost]//Put does not seem to be supported from view, as formMethod I can set only to FormMethod.POST or FormMethod.GET
		 [ValidateAntiForgeryToken] //DataAnnotation to validate the token between cookie and hidden field.
		 public ActionResult Save(Customer customer)
		 {
			if (!ModelState.IsValid)
			{
				var viewModel = new CustomerFormViewModel
				{
				Customer = customer,
				MembershipTypes = _context.MembershipTypes.ToList()
				};
			
				return View("CustomerForm", viewModel);
			}
			---------------------------
			---------------------------
			---------------------------
			_context.SaveChanges();
			return RedirectToAction("Index");
		 }
		
			
Exercise:
-----------
	Implement the validations in Movie form, enable Client side validation, Validation Summary, AntiForgeryToken.
	
		-> check current way of working what are the validations exist?
		-> enable Validation Summary?
		-> Add Client side validation
		-> enable AntiForgeryToken
		
		
	When doing that, we can notice for release date, Number in stock fields prepopulated with default values of (01-01-0001) and 0 respectively.

	why do we get this initial setting of default value? Because we set the new instance of movie object to MovieFormViewModel while calling NewMovie action, which does the automatic initialization of the properties to default values.
	
	But if we remove this instance from MovieFormViewModel, then we start getting "Id field is required validation". We need to assign some default value to the hidden field as well as need to avoid it showing in the form with default - 0.	
	
		We can use this helper: "@Html.Hidden("Movie.Id", 0)" 
		but the problem with this is obvious because of the hard coded magic string. 
		
	Then what can we do?
		-> I can do fields nullable, from Movie domain class - Id - nullable, ReleaseDate nullable, but this is not ideal scenario, releaseDate and Id cannot have null values as any record saved in DB must have an ID generated and the movie must have a ReleaseDate thats the real case scenario.
		
		So we need a viewModel where we can make these fields a nullable ones, in that way, we can make the new movie form loads fine without any default values and as we can decorate these fields with [Required] attribute we can make these fields when submit should be having a proper value.
		
		Lets try this.
				-> Create a view model with these properties nullable and with required data annotations.
				-> Yes it does work.
				
View Model Code:
-----------------

  public class MovieFormViewModel
  {
    public MovieFormViewModel()//when passing new instance, we set id to 0.
    {
      Id = 0;
    }

    public MovieFormViewModel(Movie movie) //this will be during edit scenario.
    {
      Id = movie.Id;
      GenreId = movie.GenreId;
      Name = movie.Name;
      NumberInStock = movie.NumberInStock;
      ReleaseDate = movie.ReleaseDate;
    }
	
    public int? Id { get; set; }
    [Required]
    public string Name { get; set; }

    [DateShouldBeAtleast2MonthsOld]
    [Required]
    [Display(Name = "Release Date")]
    public DateTime? ReleaseDate { get; set; }

    [Required]
    [Display(Name = "Number in Stock")]
    [Range(1, 20)]
    public int? NumberInStock { get; set; }

    [Required]
    [Display(Name = "Genre")]
    public int GenreId { get; set; }
	
    public IEnumerable<Genre> Genres { get; set; }
  }			

Movie Form
-----------
@using System.ServiceModel.Security.Tokens
@model Vidly.ViewModels.MovieFormViewModel
@{
    ViewBag.Title = "MovieForm";
    Layout = "~/Views/Shared/_Layout.cshtml";
}



<h2>
    @Model.Title
</h2>


@using (Html.BeginForm("Save", "Movies", FormMethod.Post))
{
    @Html.ValidationSummary(false, "Please fix the following errors")
    <div class="form-group">
        @Html.LabelFor(m => m.Name)
        @Html.TextBoxFor(m => m.Name, new { @class = "form-control rounded-1 mt-1 mb-1" })
        @Html.ValidationMessageFor(m => m.Name)
    </div>
    <div class="form-group">
        @Html.LabelFor(m => m.ReleaseDate)
        @Html.TextBoxFor(m => m.ReleaseDate, "{0: dd/MM/yyyy}", new { @class = "form-control rounded-1 mt-1 mb-1" })
        @Html.ValidationMessageFor(m => m.ReleaseDate)
    </div>
    <div class="form-group">
        @Html.LabelFor(m => m.GenreId)
        @Html.DropDownListFor(m => m.GenreId,
                                new SelectList(Model.Genres, "Id",
                                    "Name"), "Select Genre",
                                new { @class = "form-select mt-1 mb-1" })
        @Html.ValidationMessageFor(m => m.GenreId)
    </div>
    <div class="form-group">
        @Html.LabelFor(m => m.NumberInStock)
        @Html.TextBoxFor(m => m.NumberInStock, new { @class = "form-control rounded-1 mt-1 mb-1" })
        @Html.ValidationMessageFor(m => m.NumberInStock)
    </div>
    <button class="btn btn-primary rounded-2 mt-1 mb-1" type="submit">Save</button>
    @Html.HiddenFor(m => m.Id)
    @Html.AntiForgeryToken()
}

@section scripts
{
    @Scripts.Render("~/bundles/jqueryval");
}

MovieFormViewModel
-------------------

namespace Vidly.ViewModels
{
  public class MovieFormViewModel
  {
    ----------------------------------
	----------------------------------
	----------------------------------

    public string Title => Id == 0 ? "New Movie" : "Edit Movie"; //Added this property to return NewMovie or EditMovie string to be displayed in form.
  }
}

Web API:
---------
	Before jumping on to that, lets review quickly ASP.Net MVC Architecture.
	
		"
		When a request arrives at our application -> MVC framework -> hands over the request to the action method in a controller. 
		"

	This action method most of the times returns a View which is then parsed by razor engine and then eventually HTML markup is rendered to the client.
	
	So in this approach, HTML markup is generated on the server and then returned to the client.
	There is also an alternative approach where the HTML markup can be generated on the client side, so instead of actions returning mark up and it can return raw data.
	
	But what is the advantage of just returning data and not HTML markup?
		1. Uses less server resources as it hands of generating views to the client side.
		2. Less Bandwidth: Minor performance improvement as returning data is little more faster than generating a view and returning it.
		3. Can help serve muliple clients like (Mobile App, Web Client, Tablet App), support broad range of clients.
		
	We call these end points data services or web API as these just returns data not View.
	These web APIs are not just for building Mobile Apps or Tablet App, but can be exposed to be consumed by third party Apps/Web sites to build new functionalities.
	
	Like Twitter, Youtube, Google exposes public data services which can be consumed by our applications.
	Framework we use to build these data services is called "ASP.NET Web API". It follows the same architecture as ASP.Net MVC.
	
	So with these APIs, the data can be returned, we can use some jQuery pluggin to build the view using this data, we do not need to write much of client side code as using this pluggins automatically helps us for that.
	
RESTful Convention:
--------------------
	In this section, we will be creating Web APIs for Customer entity -> The endpoint would be as below;
		
		=> Get All 			- 		Http GET 	- 	api/customers
		=> Get By Id 		- 		Http GET 	- 	api/customers/1 (id of the customer to be retrieved)
		=> Add customer 	- 	 	Http POST  	- 	api/customers (customer data sent in the body)
		=> Update Customer 	- 		Http PUT 	- 	api/customers/1 (id of the customer to be updated)
		=> Delete Customer 	- 		Http DELETE - 	api/customers/1 (id of the customer to be deleted)
		
	This request type / convention and end points is a standard convention referred as RESTful convention.
	REST - Representational State Transfer - this may not make any sense, as this was originally part of a thesis of a PhD student.
		
	But practically, the above are the basic request types and end point format can be seen across most of the Http services or Web APIs.

Now lets build Web APIs for the Customer entity
------------------------------------------------
	-> Create API folder inside controllers
	-> Create API CustomersController
	-> Create end points GetAll, GetById
	-> Create end points for POST, PUT
	-> Create end points for DELETE

	While adding API Controller -> I had to install below packages: 
		-> Install-Package Microsoft.AspNet.WebApi.Core
		-> Install-Package Microsoft.AspNet.WebApi.WebHost
		
	Added the end points to the API/CustomersController file.
	For the context -> in the empty constructor -> assigned the new VidlyDbContext object to the _context field which can be used in the controller to access or modify the customer entity.

Controller file:
-----------------
namespace Vidly.Controllers.Api
{
  public class CustomersController : ApiController
  {
    private readonly VidlyDbContext _context;

    public CustomersController()
    {
      _context = new VidlyDbContext();
    }

    public CustomersController(VidlyDbContext context)
    {
      _context = context;
    }
	
    //api/customers
    public IList<Customer> GetCustomers()
    {
      return _context.Customers.ToList();
    }
	
    //api/customers/1
    public Customer GetById(int id)
    {
      var customer = _context.Customers.SingleOrDefault(c => c.Id == id);
      return customer ?? throw new HttpResponseException(HttpStatusCode.NotFound);
    }

    [HttpPost]
    //api/customers
    public Customer Add(Customer customer)
    {
      if (!ModelState.IsValid)
      {
        throw new HttpResponseException(HttpStatusCode.BadRequest);
      }
      else
      {
        //we have to add customer to context.customers
        var newCustomer = _context.Customers.Add(customer);
        _context.SaveChanges();
        return newCustomer;
      }
    }

    [HttpPut]
    //api/customers/1 (with request body) 
    public Customer Update(int id, Customer customer)
    {
      var existingCustomer = _context.Customers.SingleOrDefault(c => c.Id == id);
      if (existingCustomer == null)
      {
        throw new HttpResponseException(HttpStatusCode.NotFound);
      }
      else
      {
        //update each properties for the customer
        //instead of assigning these values individually, we can use tools to auto map these properties like AutoMapper.
        existingCustomer.Name = customer.Name;
        existingCustomer.BirthDate = customer.BirthDate;
        existingCustomer.MembershipTypeId = customer.MembershipTypeId;
        existingCustomer.IsSubscribedToNewsletter = customer.IsSubscribedToNewsletter;

        _context.SaveChanges();
        return existingCustomer;
      }
    }

    [HttpDelete]
    //api/customers/1 
    public Customer Delete(int id)
    {
      var existingCustomer = _context.Customers.SingleOrDefault(c => c.Id == id);
      if (existingCustomer == null)
      {
        throw new HttpResponseException(HttpStatusCode.NotFound);
      }
      else
      {
        //remove customer from the DB
        _context.Customers.Remove(existingCustomer); //this object will be marked as removed in memory
        _context.SaveChanges();
        return existingCustomer;
      }
    }
  }
}

Next is Testing these APIs:
---------------------------
	Simply in browser: 
		https://localhost:44318/api/customers/ - Lists all customer in XML format
		https://localhost:44318/api/customers/1 - fetch customer with id : 1
		
	But why in XML format? 
	----------------------
		Basically ASP.Net Web API has something called as Media formatter
	
	What does Media Formatter do?
	------------------------------
			
			[Action Result Object] --> [Media Formatter] --> Serializes --> [Output]
			
			-> Whatever API action method returns will be serialized to format what client asks for.
			This can be seen in Response headers in developer tools, content type property.
			
					Content-Type: application/xml; charset=utf-8

			In this case, it is set to "application/xml" by default when Content-Type property is not set in the request headers, then it assumes it has to return in xml format.
	
		But when we use Postman, we can see the output either in Json or XML format.
		Json is native for Javascript, it is neat and clean, it does not have any more noisy opening, closing tags as in XML and it is being used most widely.
	
	While testing, for GET and POST it did work without any issues. But for PUT and DELETE, had to add these in the web.config to make it work;
		
		<system.webServer>
			<modules>
				<remove name="WebDAVModule"/>
			</modules>
			<handlers>
				<remove name="WebDAV" />
				<remove name="ExtensionlessUrl-Integrated-4.0" />
				<add name="ExtensionlessUrl-Integrated-4.0" path="*." verb="GET,HEAD,POST,DEBUG,DELETE,PUT" type="System.Web.Handlers.TransferRequestHandler" preCondition="integratedMode,runtimeVersionv4.0" />
			</handlers>
		</system.webServer>

Now all end points work well.

Next we will talk couple of issues with design of our APIs.

Data Transfer Objects
----------------------
	Right now there are some issues with our APIs, mainly it receives or returns the domain model objects (i.e., Customer) which can be frequently changed as part of implementing new features, like we might add some more fields (address, email, phone number etc.,) or renaming the existing fields can cause breaking change at the consumer's end which is more constly.

	It is not allowed, so we need to keep contract changes as less frequent as possible (that goes into versioning of APIs) than domain model changes.

	So obvious thing is not to use domain object in the API endpoints, and need some more middle layer object to transfer the data between API and Domain that is what called as DTO.

	We will try it by mapping customer -> customerDto manually first then we see the next section where the mapping is done automatically (AutoMapper)	
		
 		First lets create a CustomerDto -> with same properties of Customer.
		And while saving map the customerDto properties to Customer entity and save it.
		
		Lets test if it works.
		
		Yes it works as expected.
		
Sample snippet: AddCustomer()
------------------------------		
	public Customer Add(CustomerDto customer)
    {
      if (!ModelState.IsValid)
      {
        throw new HttpResponseException(HttpStatusCode.BadRequest);
      }

      //Map customer Dto to customer properties
      //we have to add customer to context.customers
	  // This logic basically needs to be at domain side like facade/service file.
      var newCustomer = new Customer
      {
        Name = customer.Name,
        BirthDate = customer.BirthDate,
        IsSubscribedToNewsletter = customer.IsSubscribedToNewsletter,
        MembershipType = customer.MembershipType,
        MembershipTypeId = customer.MembershipTypeId
      }; 
      _context.Customers.Add(newCustomer);
      _context.SaveChanges();
      return newCustomer;
    }
		
AutoMapper
-----------
	Install package from Package Manager Console -> ALT + Y.
		
					install-package automapper -version:4.1
		Once installed, we have to create a mapping profile which can inherit "Profile" an AutoMapper class having methods like CreateMap(), but lets see how are these being used.
		
		In its constructor method;
		---------------------------
			we use  Mapper.CreateMap<Customer, CustomerDto>();
					Mapper.CreateMap<CustomerDto, Customer>();
			
			Mapper is a static class, having several methods -> CreateMap, DynamicMap, Map etc.,
			
			This is basically the main entry point for the AutoMapper for both creating Maps and Performing Maps.
			
	what it does internally?
	-------------------------
		When we call createMap class, it uses Reflection and scan the types and finds the properties of the both objects and maps them based on their property names, thats why AutoMapper is called Convention based mapping tool because it uses property names as convention to map objects.
		
	We need to load this profile when the application started.
				Mapper.Initialize(c=> c.AddProfile<MappingProfile>());
			
Now the Add action becomes:
---------------------------
[HttpPost]
 //api/customers
 public CustomerDto Add(CustomerDto customerDto)
 {
   if (!ModelState.IsValid)
   {
     throw new HttpResponseException(HttpStatusCode.BadRequest);
   }

   //Map customer Dto to customer properties
   //we have to add customer to context.customers
   //var newCustomer = new Customer
   //{
   //  Name = customerDto.Name,
   //  BirthDate = customerDto.BirthDate,
   //  IsSubscribedToNewsletter = customerDto.IsSubscribedToNewsletter,
   //  MembershipType = customerDto.MembershipType,
   //  MembershipTypeId = customerDto.MembershipTypeId
   //}; 
   //instead of the above lines, when using AutoMapper
   var newCustomer = Mapper.Map<CustomerDto, Customer>(customerDto); // This tells from CustomerDto -> Customer object
   _context.Customers.Add(newCustomer);
   _context.SaveChanges();
   
   //Once saved, we return DTO object with Id generated for new customer.\
   customerDto.Id = newCustomer.Id;
   return customerDto; //returns CustomerDto
 }
 
 
 GetById:
 --------
	public CustomerDto GetById(int id) //returns CustomerDto
    {
      var customer = _context.Customers.SingleOrDefault(c => c.Id == id);
      if(customer == null)
          throw new HttpResponseException(HttpStatusCode.NotFound);

      return Mapper.Map<Customer, CustomerDto>(customer);//From Customer -> CustomerDto object.
    }
	

Verify it for GetAll and PUT, Delete methods?????? - done.
	
	Right now if we see the responses are in Pascal Casing as FirstLetter each word is "Capital".
	
	But most often in Javascript we consider the properties of response would be "camelCasing".
Now, how do we enable camelCasing in our WebApiConfig to have our responses in "camelCasing"?

Code Snippet:
-------------
	We take JsonFormatter serializer settings and set its contractResolver to CamelCasePropertyNamesContractResolver object.
		
		"
			var settings = config.Formatters.JsonFormatter.SerializerSettings;
			settings.ContractResolver = new CamelCasePropertyNamesContractResolver();
		"
 
Making the response more RestFul convention, right now for post also it returns with 200 status code, 
that is success, but as per RestFul convention, it should be 201 Created.

To make it that way, we can use IHttpActionResult interface as return assimilar to ActionResult in MVC. 	
And for returning we can use helper methods offered by API Controller -> can use its overload methods to return response.

Sample Add method:
-------------------

public IHttpActionResult Add(CustomerDto customerDto)
{
  if (!ModelState.IsValid)
  {
    return BadRequest(ModelState);//helper method, returns with Model validation messages.
  }

	-------------------
	-------------------
	-------------------
  //instead of the above lines, when using AutoMapper
  var newCustomer = Mapper.Map<CustomerDto, Customer>(customerDto);
  _context.Customers.Add(newCustomer);
  _context.SaveChanges();
  
  //Once saved, we return DTO object with Id generated for new customer.\
  customerDto.Id = newCustomer.Id;
  return Created(Request.RequestUri + customerDto.Id.ToString(),customerDto); //return with location of the new id created, actual customer object created.
}




				
					
					