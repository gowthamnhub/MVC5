MVC 5 Course from Mosh Hamedani
--------------------------------
What is MVC?
------------
	-> MVC is one of the Architectural Pattern for implementing user interfaces.
	-> it stands for Model(data and business logic), View(UI), Controller(handles user input).
	-> It always have another component which is not in the Acronym - "Router" which selects the right controller/action method to handle the request based on certain rules.
	
What is Architecture?
-----------------------
	-> Software architecture is high level structure of the system or blueprint of the system that outlines how different
components of the system interact and work together to achieve the overall goals of the system.	
	
What is Architectural Pattern?
-------------------------------
	-> General design pattern helps to architecture the system in way to have better scalability, maintainability, flexibility and other desirable qualities to solve the common problem that occur, these guidelines are well tested over many years and developed by the community for solving commonly occuring problems.
		Examples:
					-> Layered Architecture
					-> Client-Server Architecture
					-> Model-View-Controller Architecture
							-> MVC pattern says Router will select the controller/action based on the URI and pass the request to that particular action method, controller facilitates fetching the data (model) and passing the data to UI and return response.
					-> Microservices Architecture
					-> Event-Driven Architecture
					-> Singleton Pattern
					-> Observer Pattern
					
					
Creating .Net Framework Project with MVC:
-----------------------------------------
RouteConfig.cs -> in App_Start folder -> has the rules defined for route.
Global.asax.cs -> class which hooks for various events in the application life cycle.
					-> When the application starts, Application_start method starts execution and it does register some of the things like RegisterRoutes().
					-> it basically tells the run time these are the routes for the application.

Packages.config -> similar to npm to manage dependent packages of our application.					
				-> all the dependent packages/libraries will be updated/managed by using packages.config

Startup.cs -> all the startup logic for the application will be moved to this file from .Net core, dropping Global.asax file.
Web.config: 
------------
		Mostly we will work only in 2 sections in this xml - ConnectionString (define DB connection) and AppSettings (define configuration settings for our application)			
					
We will start adding models (POCO - plain old clr or c# objects) which represents the state and behavior of our application in terms of the problem domain.	

For eg:
--------
public class Movie //in this case it does not have any behavior, but only properties.
{
    public int Id { get; set; }
    public string  Name { get; set; }
}

To make a controller to handle our request and return response, we have to add a controller file in controllers folder,
for eg; MoviesController which is just another class but it becomes powerful when it derived from Controller class, because that provides the ability/methods for the MoviesController class to handle and responde to http request that are made to the ASP.Net MVC web site.

	Example: Json(), View(), OnActionExecuting(),OnActionExecuted(), OnAuthentication(), OnException(), PartialView(), RedirectToAction(),RedirectToRoute()
			Properties like Request (Gets HttpRequestBase object for current Http request), Response (Gets HttpResponseBase object for current HttpResponse), User (Gets user security information for current Http request) etc.,
			
	We can even place the controller class inside models, but recommended and most followed practice is to keep controller classes inside Controller folder.

MoviesController:
------------------
  public class MoviesController : Controller
  {
      // GET: Movies
      public ActionResult Index()
      {
          var movies = new List<Movie>()
          {
              new Movie { Id = 1, Name = "Shrek!" },
              new Movie { Id = 2, Name = "Dark" },
              new Movie { Id = 3, Name = "Just love!" }
          };
          
          return View(movies);
  }
  
 Corresponding View:
------------------------
@model IEnumerable<Vidly.Models.Movie>
@{
    ViewBag.Title = "Index";
    Layout = "~/Views/Shared/_Layout.cshtml";
}

<h2>Movies List</h2>

@foreach (var item in Model)
{
    <h5>@item.Name</h5>
}


To change theme of the default project:
---------------------------------------
	-> Go to Bootswatch.com -> Themes -> Select from multiple option. I select Pulse and downloaded Bootstrap.css file.
	-> Renamed it as Bootstrap-pulse.cs and placed it in content folder where bootstrap files are present.
	-> To make our project to use this Bootstrap-pulse.css file, go to RegsiterBundles in BundleConfig.cs -> where the client side files (js, css) are bundled so that in one http request all the files will be loaded without making multiple http request for each style/js files.
	
	There we can make the css style bundle to point to this new theme file.	Theme would be altered for the app.
	
            bundles.Add(new StyleBundle("~/Content/css").Include(
                      "~/Content/bootstrap-minty.css",
                      "~/Content/site.css"));
 
 
ASP.Net MVC Fundamentals:
--------------------------
	ActionResult:
	-------------
		-> We can see that from action method, that it is returning ActionResult - what is it?
		-> it is an abstract class having abstract method ExecuteResult()
		-> basically it is derived by different result classes, viewResult, JsonResult, ContentResult, RedirectResult(to redirect to URI), RedirectToRouteResult(redirects to a route) etc.,
		
	But what does return View() do - we have not mentioned anywhere ViewResult? Then how does it return ViewResult object.
	Actually there is a helper method defined in Controller class to return specific ActionResult object(since all viewResult, jsonResult, ContentResult etc., are derived from ActionResult).
	
	So, the code:
						"return View(model);" 
		returns a ViewResult object using the model that renders view to the response.

See below eg; This code is from Controller class;
--------------------------------------------------
    protected internal virtual ViewResult View(string viewName, string masterName, object model)
    {
        if (model != null)
        {
            base.ViewData.Model = model;
        }

        return new ViewResult
        {
            ViewName = viewName,
            MasterName = masterName,
            ViewData = base.ViewData,
            TempData = base.TempData,
            ViewEngineCollection = ViewEngineCollection
        };
    }
	
So like this, for different types of ActionResult, there is a helper method present in Controller class like below;
-----------------------------------------
PartialViewResult - PartialView()
ContentResult     - Content()
RedirectResult    - Redirect()
RedirectToRoute   - RedirectToAction()
JsonResult        - Json()
FileResult        - File()
HttpNotFoundResult- HttpNotFound()
EmptyResult       - no helper method (as per the course 2016)
----------------------------------------

If suppose we want to redirect request to different route/action/controller, we can do it like below;

return RedirectToAction("Index", "Home", new { page = 1, sortBy = "name" });

in this "new { page = 1, sortBy = "name" }" this portion is know as anonymous object.

in the URI - it looks below; https://localhost:44318/?page=1&sortBy=name after redirection.

Action Parameters:
-------------------
	--> ActionResult is the output from Action, Action Parameters is the input to the Action methods.
	--> MVC Framework does the parameter binding automatically from URI to action parameters.
For eg;
------
		https://localhost:44318/movies/edit/23?movieId=300 
		This movieId will bind to the below action method;
		 
			public ActionResult Edit(int? movieId)
			{
				return Content(String.Format("id = {0}", movieId));
			}
			
		but the same would not work when the request is simply; https://localhost:44318/movies/edit/300
			as per the default route this is termed as {id}

	See RouteConfig:
	-----------------
		routes.MapRoute(
							name: "Default",
							url: "{controller}/{action}/{id}",
							defaults: new { controller = "Home", action = "Index", id = UrlParameter.Optional }
						);
						
		But if i make it changed to "{controller}/{action}/{movieId}"	- then it will work;
		
		But if suppose, we want to have our url like below;
			
		https://localhost:44318/movies/random/pageIndex=2&sortBy=Name
		
		When I have below action method, then above URI works.
		
				    public ActionResult Random(int? pageIndex, string sortBy)
					{
						return Content(String.Format("pageIndex = {0}, sortBy={1}", pageIndex.Value, sortBy));
					}
		
But instead of query string if we want to call like; 		
		
		https://localhost:44318/movies/random/pageIndex/2/sortBy/Name
		or 
		https://localhost:44318/movies/random/2/Name
		
	These won't work as per our current route config, we have to have a custom route defined for handling these kind of URLs.	
	Because the way the current routing works called as Conventional based routing.
	
	But when we have scenarios like to pass multiple parameters to fetch the data.
	Suppose in our app, we want to fetch all the movies by release year and month like below;
						
						"/movies/released/2015/04"
						
	Custom route defined: it has multiple overloads, generally used one, name, url, defaults
	---------------------
		routes.MapRoute(
						name: "ByReleaseDate",
						url: "movies/released/{year}/{month}",
						defaults: new
						{
							controller = "Movies", action = "ByReleaseDate", year = 2020, month = 01
						},
						
						new {year = @"\d{4}", month=@"\d{1,2}"}
						); 
						
		"new {year = @"\d{4}", month=@"\d{1,2}"}" --> constraints can be added in the route, here year should 	be 4 digits, month to have 1 or 2 digit.				
		
		The result URL: https://localhost:44318/movies/released/2022/14				

Attribute Routing:
------------------
		In the above approach, we have just added just one custom route in RouteConfig, but overtime, there would be needing a lot of custom routes to be defined and this file would become messy and error prone as we are entering the hard coded string for action name, if at all we change the action name in the controller, this will cause issues. It becomes unmaintainable.
		
		Instead of this, we can give custom route defined just above the action method itself, so we won't have such above issues.

		To use Attribute Routing, we need to enable it in RouteConfig.cs.
					
					routes.MapMvcAttributeRoutes();
					
		Above action method, we can use Route Attribute to provide the required url to hit the respective action.
		Eg:
		--
			       [Route("movies/released/{year:min(1960):max(2023)}/{month:max(12)}")]
					public ActionResult ByReleaseDate(int year, int month)
					{
						return Content($"year: {year}, month:{month}");
					}
					
			We can also provide constraints in the route parameter by {year:min(1960)}/{month:max(12)}	

				https://localhost:44318/movies/released/2024/12 - this does not work, says 404 - due to constraints specified as it works only from 1960 - 2023.

Passing Data to Views:
----------------------
	Different ways of passing data to views, most easy and better one is pass it as model.
	One of the early days of MVC, ViewDataDictionary was the one used for passing data from controller to views.
	But since this is dynamic type, we have to do explicit casting in View to use it.
	
	ViewData: this comes from ControllerBase class.
	---------
	
			@foreach (var item in (List<Movie>)ViewData["movies"])//explicit casting and same hard coded string.
			{
				<h5>@item.Name</h5>
			}
	From Controller: 
	-----------------
			public ActionResult Index()
			{
				var movies = new List<Movie>()
				{
					new Movie { Id = 1, Name = "Shrek!" },
					new Movie { Id = 2, Name = "Dark" },
					new Movie { Id = 3, Name = "Just love!" }
				};
			
				ViewData["movies"] = movies;
				
				return View();
			}
	ViewBag: this also come from ControllerBase class - it is dynamic view data dictionary.
	--------
		@foreach (var item in ViewBag.movies)
		{
			<h5>@item.Name</h5>
		}
	From Controller:
	----------------
		 ViewBag.movies = movies; //instead of hard coded string, it is dynamic property, but here also if there are typo, no compile time check.
		 
Passing View Models to View:
----------------------------
			View Models are models specific to Views.
			This generally goes to seperate folder (ViewModels) than Models. As models folder is specific to domain classes which is independent of UI.	
					
RazorView Syntax:
------------------	
		This helps writing C# syntax and html tags together.
		Basically, the ViewEngine in the MVC called Razor View Engine knows how to parse the syntax and understand.

								Example: (MoviesWithRentedCustomers.cshtml)
								--------------------------------------------
								@model Vidly.ViewModels.MovieCustomersViewModel
								
								@{
									ViewBag.Title = "title";
									Layout = "~/Views/Shared/_Layout.cshtml";
								}
								
								<h2>@Model.Movie.Name</h2>
								
								<ul>
									@foreach (var item in Model.Customers)
									{
										<li>@item.Name</li>
									}
								</ul>
								
Partial Views:
---------------
		Reusable views. Does not have a Layout.
		General convention is to prefix partial view with "_" like "_Layout" , "_NavBar"

Sample
-------
	 @Html.Partial("_NavBar");
	 <div class="container body-content">
		 @RenderBody()
		 <hr />
		 <footer>
			 <p>&copy; @DateTime.Now.Year - My ASP.NET Application</p>
		 </footer>
	 </div>		
	 
But it looks like there is no distinction between partial view or regular views, it is just the convention and assumption made by the framework to locate the file and render.

		@Html - HtmlHelper Property - it has some useful methods to create and render html elements in View.
		
Exercise to show Customer, Movies link in NavBar and on click show respective customer as link ->which redirects to details. But movie link is not a link, if we want we can make it.		
		
						Mosh - GitHub Link - https://github.com/mosh-hamedani/	

ENTITY FRAMEWORK:
------------------
	What is entity framework?
		It is basically a Object/Relational Mapper(ORM) tool which means it maps data in a relational database into objects of our application.
		Old days, this mapping of data to objects needed to be done manually by;
			-> Opening a connection
			-> Executing a command
			-> Reading data
			-> Form an object.
			-> finally remembering to close the connection.
			
	With ORM, we don't have to do this steps anymore, it is automatically done for us by the framework, we work at a higher level of abstraction.
		EF provides a called "DbContext" which is a gateway to our database.
		
			DbContext ----------> DbSet/s 
			(database)			  (table)
			
		We use LINQ to query the DbSet, EF will translate it to SQL queries at run time which opens the Db connection, reads the data, maps it to objects and adds them to DbSet in DbContext.
		
	So when Add/Delete/Update to our DbSet, EF keeps track of these changes, once we ask for it to persist the changes, it will automatically generate the SQL statements and executes them on Database.

	Two workflows to use EF;
			-> Database First
					- Traditional way to design database tables first and then have EF generate the corresponding domain classes.
					----------------------------------
					|Domain Classes <= EF <= Database|
					----------------------------------
			-> Code First
					- This is opposite to above approach, we will create domain classes first, then have Entity Framework to generate DB tables. 
					----------------------------------
					|Domain Classes => EF => Database|
					----------------------------------
					
		So as part of this course, we are going to take Code First approach and here are the reasons why?
				-> Increases Productivity as we don't have to waste our time with table designers.\
				-> its very much faster to write code.
				-> when we have code first, we get full versioning of the database and can be migrated to any version any point in time. Since we use migrations in code first approach it is possible.
				-> Much easier to build integration test db.
		
		Few misconceptions about Code First approach: (these are true myths)
		---------------------------------------------	
			-> This is only useful with new projects or greenfield projects.
			-> If you have a application with existing database, code first do not work.
			-> it does not give you full control over db.

CODE FIRST MIGRATIONS:
----------------------
	What are migrations?
	--------------------
		-> In EF, migrations are the way to manage changes to the database schema over time. They provide a way to update the database to reflect the changes from data model (like adding/modifying columns or relationships).
		-> It is simply a set of instructions, which tells how the database schema should be updated.
		-> EF also keeps track of which migrations applied to the database, this version tracking helps ensure that the database schema is in sync with the application's data model.	
		
	Steps and flow:
	---------------	
		-> In Code first workflow, we start with code, everytime we modify our domain model by adding/modifying class, we create a migration and run it on the database.
		
		-> First install Entity Framework from Tools -> Nuget Package Manager -> Manage Nuget Packages for Solution -> 	  Search for Entity Framework -> install
			
		-> Before adding migration, we need to enable migrations by using "enable-migrations".
		-> once enabled, Add-Migrations InitialModel(describing message about the change)
		-> Adds a migration file in the "Migrations" folder - it clearly tells about the change - if it is createTable, or any other change, this file would be derived from DbMigration class which has methods to createTable, AddColumn, DropColumn etc.,
		
		-> To update database -use "update-database".\
		-> pushes changes to the database/updates the database.
		-> here in this case, click on "show all files" -> App_Data folder -> check the .mdf file created. where the tables are created.
		
		-> We can find our customers, movies table over there, also we can find another table _MigrationHistory which maintains the history of migrations applied on this database.
			
		-> With this Entity framework knows what version of database our application currently at.
	
Changing the Model:
--------------------
	-> In the vidly app, right now the domain classes are very simple. 
	-> if suppose we want to add few more properties to Customer, like (their MemberShipType, IsSubscribedToNewsletter).
	-> MemberShipType can have information like SignUpFee, Duration, DiscountRate.
	-> Each customer can have one and only MemberShipType.
		
		In this SignUpFee cannot be more than 32000$, for that we can have short type.
		Duration - can be between 1-12 months - so byte type (-127 to +128)
		DiscountRate - can be between (10% - 100%) so byte type.
		Any entity in EF should have primary key, by convention it should be named Id or EntityName + Id.
		Here in MemberShipType's "Id" can be of byte type as the MemberShipTypes would be 4 or 5 itself.	
		
		MemberShipType is known as Navigation property, because it allows us to navigate from one type to another, here from Customer type to its MemberShipType. 
			-> its useful when we want to load an object and its related objects together from the database.
			-> Here, we can load the customer and its MembershipType together.
		If suppose we don't to load all the related objects together, for optimization purpose, we can have another property by naming convention - MemberShipTypeId - EF recognizes it as foreign key.	
		
						public byte MembershipTypeId { get; set; }
		
For making this changes, we will aim for small migrations and keep adding further, instead of making all these changes at once and going big migration which is error prone.

Seeding the Database:
---------------------
		Seeding the data to the MemberShipType table as it do not have any records still.
		Pay-as-you-go - Free, Monthly - 30$, Quarterly - 90$, Annually - 300$		

						"Add-Migration PopulateMembershipType"
		
		In the Up method;
			public override void Up()
			{
				Sql("INSERT INTO MembershipTypes(Id, SignUpFee, DurationInMonths, DiscountRate) VALUES(1,0,0,0)");
				Sql("INSERT INTO MembershipTypes(Id, SignUpFee, DurationInMonths, DiscountRate) VALUES(2,30,1,10)");
				Sql("INSERT INTO MembershipTypes(Id, SignUpFee, DurationInMonths, DiscountRate) VALUES(3,90,3,15)");
				Sql("INSERT INTO MembershipTypes(Id, SignUpFee, DurationInMonths, DiscountRate) VALUES(4,300,12,20)");
			}
			
						"update-database"
						
		If you notice in the Migration_History, we have all the migrations from start executed, in this way, we can have the Migration SQL script created by using a command in Package manager console to include all these migrations in single file and get it executed in a test/production environment as we have the scripts ready in hand with this versioning of migrations.
		
		If we do it manually, then we need to have it maintained somewhere or consolidated from multiple developers tpo get it executed in test or production environment. And you know its very tough.
			
			
Overriding Conventions:
-----------------------
		Since, we have given Name property in Customer is string type - which is nullable, EF also generates it as a nullable field and nvarchar(max) length.
		We can use DataAnnotations to override these conventions.
		
		After using DataAnnotations (Required, StringLength(255) on Name property) after add-migration, update-database
		the database schema is updated with column name now have nullable: false, maxLength: 255
		
Querying objects:
-----------------
		Currently, the customer details are hardcoded in Customer controller and sent to view.
		If we need to query the customers from Database, we will instantiate the VidlyDbContext (as this is the gateway to access our db tables).
                                   var customers = _context.Customers;//deferred execution.
								   
				One thing to note here is when this line is executed, "_context.Customers" - it will not immediately fire queries to fetch data from db, instead it only fetch data when we iterate over.	
					But if suppose, we have ; var customers = _context.Customers.ToList(); it fires the query immediately.
					
Eager Loading:
--------------
		If suppose in the above case, we have another column showing DiscountRate for the customer means, we have to have another column added in view, to get the data for that column, 
		
								"@item.MemberShipType.DiscountRate"	
								
				But when we do this, what happens is object reference exception. Why because when loading the Customer object, it does not load MemberShipType object.				
		To make it load, we need to do something called - EagerLoading.
		When loading customers, we have to use Include method from System.Data.Entity namespace.
						
						 var customers = _context.Customers.Include(x=> x.MembershipType).ToList();
						 
To create a shortcut for package manager console:
--------------------------------------------------
							Tools -> Options -> Environment -> Keyboard -> type packagemanagerconsole -> Press respective keys and Assign -> I assigned "ALT + Y" - it is working fine.
							
Exercise 1:
-----------
	Instead of showing DiscountRate in Customers-> Index, show MemberShipType name (note we do not have name property in MemberShipType domain class)
			-> Add Name property to MemberShipType class.
			-> Add-Migration Added-Name-MembershipType
			-> update-database
			-> Add- Migration Update-MemberShipType-Name
			-> Use SQL method in Up() method to provide update statement to update name for all membershiptypes.
							
							
Exercise 2: 
------------
	Add Birthdate to Customer

Exercise 3:
------------
	Display List of movies and their details (Release Date, Genre, Date Added).	

Lets Add Forms:
----------------
	-> For Adding/Editing Customers/Movies.
	-> For that first we need an action in Controller to bring the Create Form where user can enter their details like (Name, Birthdate, Subscribed to newsletter) fields for customers.
    -> For movies it would be (Name, Genre, ReleaseDate, AddedDate, NumberInStock)	
	
	For Adding Customer, add an action method (create) in Customers Controller which returns a View(form).
	View contains form controls for user to provide the details.
	So in plain html, we use form tag -> input fields, labels.
	Here in this, we can use Html helper methods to add html controls.
	
	Some of the html controls are; and in bootstrap it follows the certain classes to have it styled in modern manner.

/*************************************************************************************************/	
@using (Html.BeginForm("Create", "Customers"))//by using tag, it automatically closes </form> tag at the end.
{
    <div class="form-group">
        @Html.LabelFor(m => m.Name)
        @Html.TextBoxFor(m => m.Name, new { @class = "form-control" })
    </div>
    <div class="form-group">
        @Html.LabelFor(m => m.BirthDate)
        @Html.TextBoxFor(m => m.BirthDate, new { @class = "form-control" })
    </div>
    <div class="form-check">
        <label class="form-check-label">
            @Html.CheckBoxFor(m => m.IsSubscribedToNewsletter, new {@class="form-check-input"})
            @Html.LabelFor(m => m.IsSubscribedToNewsletter)
        </label>
    </div>
}

/*************************************************************************************************/	
	
For movies it would be (Name, Genre, ReleaseDate, AddedDate, NumberInStock)	
	
When we add Display - DataAnnotations to provide display name for the field, then we have to be aware of the fact that if we want to rename the label to show different way, then we have to rename it in model class and recompile the code and deploy for just label renaming.
		In that case, we can go for plain label tag to provide the display text manually. But "for" attribute need to be manually entered to get that effect of on click of label the form control gets focus.

			" <label for="BirthDate">Date of Birth</label> 
			 @Html.TextBoxFor(m => m.BirthDate, new { @class = "form-control" }) "
			
		Here is the risk, if we don't give the BirthDate name properly, the effect of focus do not work properly.

		
		
Drop-down Lists:
-----------------
	-> If we have to add a drop down for the customer form to select the respective MemberShipType (Pay-as-you-go, Quarterly, Monthly, Annually) a dropdown list.
	-> Currently, the customer create form takes the customer model, which does not have the entity for MemberShipTypes, So basically we need a Customer entity as well as MemberShipTypes entity as well to Create form for Customer.
	-> So lets add a ViewModel property which takes Customer and MemberShipType together.

Example:
---------
 <div class="form-group">
     @Html.LabelFor(m=> m.Customer.MembershipTypeId,
 new {@class="pb-2"}) 
     @Html.DropDownListFor(m=> m.Customer.MembershipTypeId, new SelectList(Model.MembershipTypes, "Id", "Name"), 
         "Select Membership Type", 
         new {@class = "form-select"})
 </div>	

						"class="form-select" makes the dropdown display properly."
						
Model Binding:
---------------
	MVC framework automatically binds the action parameters with the request data.
	
Saving Data:
------------
	Need to have a new action created to handle to post request - [HttpPost] to make sure this action method can be called via HttpPost not through Get request.
	
	-> As a best practice, if the action method does modify the data, it should never be accessible by HttpGet.
	-> Once the payload is received, which is then mapped to the customer parameter. 
	-> To add it to the database, we need to add it in the Customers DbSet in DbContext class.
	-> Once it is added, then to persist/commit the changes to DB, use SaveChanges() method, which then collects all the changes done on the entity (modification, addition, deletion) and fires up the queries to make the changes to Database. 
	-> This all things done under a transaction, so that if any fails, all changes gets rolled back.
	
See example below;
-------------------	

 [HttpPost]
 public ActionResult Create(Customer customer)
 {
    _context.Customers.Add(customer);
    _context.SaveChanges();
    return RedirectToAction("Index");
 }	
 
 Editing Customer:
 -----------------
	-> Since we use the same view model (NewCustomerViewModel) as this form also will show same controls, customer data, Membership dropdown. We can rename the View model to little more generic as "CustomerFormViewModel".
	-> As we already have a view to show these controls - "Create" for edit also we can use the same View with same controls just filled with existing data, so we can rename view name also to "CustomerForm" to be more generic for Create/Edit scenario.
	-> And also the same for post method, as right now it is called as Create (HttpPost), we can have the method named as "Save" to be more generic for Create/Edit, we will just check if the customer payload has "id" value == 0 - then it goes add logic, else go to edit logic. Add the id property as hidden field in the "CustomerForm.cshtml"
	
See below example:
-------------------
        [HttpPost]
        public ActionResult Save(Customer customer)
        {
            if(customer.Id == 0)
                _context.Customers.Add(customer);
            else
            {
                var customerInDb = _context.Customers.Single(c => c.Id == customer.Id);
                //TryUpdateModel or autoMapper - but these updates entire model, sometimes we may need only specific properties to be updated
                customerInDb.Name = customer.Name;
                customerInDb.MembershipTypeId = customer.MembershipTypeId;
                customerInDb.BirthDate = customer.BirthDate;
                customerInDb.IsSubscribedToNewsletter = customer.IsSubscribedToNewsletter;
            }
            _context.SaveChanges();
            return RedirectToAction("Index");
        }	
		
Exercise:
---------		
	Similar have a Add new movie link in Movies list view, and on click of that -> open Add Movie form -> with controls, Name, Release Date, Genre (ddl), Number in Stock fields and save button.
	
		-> add the link added in Movies list view
		-> add an action for New movie in movies controller
		-> create the new movie form view with fields and button to save.
		-> add a new action to save the new movie created.
		-> Add Genre DbSet in DbContext.
		
	After all done, when saving it is giving EntityValidationError, though we enter all the fields in UI, I can see, we have DateAdded property is also required, but as per UI, we do not have that field, that should be the reason for this validation message, lets check in the next section video if he explains that.
		-> We may need to add that property in UI or use Today property set everytime, we try to add a new movie.
		
	Edit Movie:
	------------
		Same MovieForm would be called from Edit Click -> Same MovieFormViewModel is passed back to Edit Action to show the same form with filled details.

	Edit Action:
	------------
	   public ActionResult Edit(int? Id)
       {
           var movie = _context.Movies.Include(x => x.Genre).FirstOrDefault(x => x.Id == Id);
           var viewModel = new MovieFormViewModel
           {
               Movie = movie,
               Genres = _context.Genres.ToList()
           };
           return View("MovieForm", viewModel);
       }
	   
	   In Movie Form:
	   --------------
					@if (Model.Movie != null)
					{
						<h2>
							Edit Movie
						</h2>
					}
					else
					{
						<h2>
							New Movie
						</h2>
					}
					
	Still not able to save, due to some validation errors.		

Entity Validation Errors Resolved:
-----------------------------------
	It was due to when Genre was required field, but from the form we get only GenreId, for that we have to remove the Required attribute for Genre property from Movie class and we will have a GenreId property added with the "same type" as in Genre class, then EF does not complain about the validation and it automatically resolves the value for GenreId to Genre property (from Id to actual object).	
	
	Save Action Method:
	--------------------
		public ActionResult Save(Movie movie)
        {
            if (movie.Id == 0)
            {
                movie.DateAdded = DateTime.Now;
                //movie.Genre = _context.Genres.FirstOrDefault(x => x.Id == movie.GenreId); this is not needed.
                _context.Movies.Add(movie);
            }
            else
            {
                //edit logic
                var movieInDb = _context.Movies.Include(m=> m.Genre).Single(m=> m.Id == movie.Id);
                if (movieInDb != null)
                {
                     movieInDb.Name = movie.Name;
                     movieInDb.GenreId = movie.GenreId;//_context.Genres.FirstOrDefault(x => x.Id == movie.GenreId);
                     movieInDb.ReleaseDate = movie.ReleaseDate;
                     movieInDb.NumberInStock = movie.NumberInStock;
                     movieInDb.DateAdded = DateTime.Now;
                }
            }
            
            _context.SaveChanges();
            return RedirectToAction("Index");
        }
		
	Movie domain class:
	-------------------
				    public class Movie
					{
						public int Id { get; set; }
						public string  Name { get; set; }
						
						[Required]
						[Display(Name = "Release Date")]
						public DateTime ReleaseDate { get; set; }
						
						[Required]//Actually this Required also can be removed as it is not a field in the form.
						[Display(Name = "Date Added")]
						public DateTime DateAdded { get; set; }
						
						[Required]
						[Display(Name = "Number in Stock")]
						public short NumberInStock { get; set; }  
						
						public Genre Genre { get; set; }
						[Required]
						public int GenreId { get; set; }
					}
		
Implementing Validations on Form:
----------------------------------
	Before Saving the data to database, we need to validate if the data / object is proper or without any errors as per our DataAnnotations set on the domain model entity. 
	We can check that with the help of "ModelState" objects "IsValid" property, which checks any of the model property has any Errors or not, if it is then it returns "false", if it is valid then returns "true".
	To show this in UI, we need to have a place holder added in the form - using @Html.ValidationMessageFor(m=> m.Customer.Name)
	
Customers Controller:
----------------------	
Save Method:
=============
        [HttpPost]
        public ActionResult Save(Customer customer)
        {
            if (!ModelState.IsValid) //Checks if the model property has any error
            {
                var viewModel = new CustomerFormViewModel
                {
                    Customer = customer,
                    MembershipTypes = _context.MembershipTypes.ToList()
                };

                return View("CustomerForm", viewModel);
            }

            if(customer.Id == 0)
                _context.Customers.Add(customer);
            else
            {
                var customerInDb = _context.Customers.Single(c => c.Id == customer.Id);
                //TryUpdateModel or autoMapper - but these updates entire model, sometimes we may need only specific properties to be updated
                customerInDb.Name = customer.Name;
                customerInDb.MembershipTypeId = customer.MembershipTypeId;
                customerInDb.BirthDate = customer.BirthDate;
                customerInDb.IsSubscribedToNewsletter = customer.IsSubscribedToNewsletter;
            }
            _context.SaveChanges();
            return RedirectToAction("Index");
        }
		
Some DataAnnotations:
----------------------
[Range(1,10)]
[Compare("Other Property")]
[Phone][Email][Url]

Custom Validation / Data Annotation
------------------------------------
If suppose I need a validation to be set for any customer to be on a membershiptype other than Pay-as-you-go, they should be atleast 18 years old.

How can I do that?
	-> Well, we can create a Custom DataAnnotation like 'Minimum18YearsAge' and apply it on birthdate property.
	-> And how we will apply the validation logic to check if the membershiptype selected is Pay-as-you-go or other? 
	-> For this we can check [Required] attribute is designed, "RequiredAttribute" is a class derived from "ValidationAttribute" class 	which is derived from "Attribute" class which is a abstract class.
	
Here is the class - "Minimum18YearsAge"

namespace Vidly.Models
{
    public class Minimum18YearsAge : ValidationAttribute
    {
        protected override ValidationResult IsValid(object value, ValidationContext validationContext)
        {
            //check if the membership selected is pay-as-you-go, if not then check age limit, if yes, just return success
            //so to check the other property here(MemberShipType), this valiationContext object helps.
            var customer = (Customer)validationContext.ObjectInstance;
            if (customer.MembershipTypeId == 0 || customer.MembershipTypeId == 1)
                return ValidationResult.Success;

            if (customer.BirthDate == null)
                return new ValidationResult("Birth date is required");
            var age = GetAgeFromBirthDate(customer.BirthDate);

            if(age >= 18) return ValidationResult.Success;

            return new ValidationResult("Age should be at least 18 years to be on a member");
        }

        private static int GetAgeFromBirthDate(DateTime ?customerBirthDate)
        {
           var age = DateTime.Today.Year - customerBirthDate.Value.Year;
           if (DateTime.Today.Month < customerBirthDate.Value.Month) return age;
           if (DateTime.Today.Day < customerBirthDate.Value.Day) return age;
           age++;

           return age;
        }
    }
}	

For resolving the issue with "The id field is required" validation in Save method, I splitted it to two actions - Create(POST) and Update(POST) - do note it is not [HttpPUT] as it did not work, as from client side, I can only set FormMethod.POST or FormMethod.GET.

In POST, we can exclude Id property using [Bind(Exclude = "Id")] attribute.

With this change, I tested Add and Edit scenarios, it is working as expected.

	"Probably we need to check how/when do we use HttpPUT or HttpDelete action verbs in MVC actions?"
	
Controller:
------------
		[HttpPost]
		public ActionResult Create([Bind(Exclude = "Id")] Customer customer)
		{
			if (!ModelState.IsValid)
			{
				var viewModel = new CustomerFormViewModel
				{
					Customer = customer,
					MembershipTypes = _context.MembershipTypes.ToList()
				};
		
				return View(viewModel);
			}
			_context.Customers.Add(customer);
			_context.SaveChanges();
			return RedirectToAction("Index");
		}

        [HttpPost]//Put does not seem to be supported from view, as formMethod I can set only to FormMethod.POST or FormMethod.GET
        public ActionResult Update(Customer customer)
        {
            if (!ModelState.IsValid)
            {
                var viewModel = new CustomerFormViewModel
                {
                    Customer = customer,
                    MembershipTypes = _context.MembershipTypes.ToList()
                };

                return View("Edit", viewModel);
            }
            else
            {
                var customerInDb = _context.Customers.Single(c => c.Id == customer.Id);
                //TryUpdateModel or autoMapper - but these updates entire model, sometimes we may need only specific properties to be updated
                customerInDb.Name = customer.Name;
                customerInDb.MembershipTypeId = customer.MembershipTypeId;
                customerInDb.BirthDate = customer.BirthDate;
                customerInDb.IsSubscribedToNewsletter = customer.IsSubscribedToNewsletter;
            }
            _context.SaveChanges();
            return RedirectToAction("Index");
        }	
	
		
		
	
		
		
	
		
			

	 




			
			
	

	
				
					
					